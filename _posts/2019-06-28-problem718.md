---
title: 718. Maximum Length of Repeated Subarray (medium)                  
author: zhou      
tags: [HashTable,Array,Binary Search,Dynamic Programming]          
---

       

## Catalog  
+ [Question Description](#partI)
+ [My Thoughts](#partII)
+ [Code Exhibition](#partIII)

----------------------------------

## Question Description
Clear language for describing question.    
Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.       

Example 1:     
Input:    
A: [1,2,3,2,1]   
B: [3,2,1,4,7]    
Output: 3    
Explanation:     
The repeated subarray with maximum length is [3, 2, 1].     

Note:    
1 <= len(A), len(B) <= 1000    
0 <= A[i], B[i] < 100     


----------------------------------

## My Thoughts
My thoughts for solving question after thinking and checking others' solving methods.        
I. Brute Force. Check for every subarray of int[] A and int[] B. while(i + k < A.length && j + k < B.length && A[i+k] == B[j+k]) is the key. But the time limit exceeded.  
II. If there is a length k subarray common to A and B, then there is a length j <= k subarray as well. Let check(length) be the answer to the question "Is there a subarray with length length, common to A and B?" This is a function with range that must take the form [True, True, ..., True, False, False, ..., False] with at least one True. We can binary search on this function. <b> Algorithm </b> Focusing on the binary search, our invariant is that check(hi) will always be False. We'll start with hi = min(len(A), len(B)) + 1; clearly check(hi) is False. Now we perform our check in the midpoint mi of lo and hi. When it is possible, then lo = mi + 1, and when it isn't, hi = mi. This maintains the invariant. At the end of our binary search, hi == lo and lo is the lowest value such that check(lo) is False, so we want lo - 1. As for the check itself, we can naively check whether any A[i:i+k] == B[j:j+k] using set structures. But this method also will time limit exceed.        
III. Dynamic Programming. Since a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know dp[i][j] = dp[i+1][j+1] + 1. Also, the answer is max(dp[i][j]) over all i, j. We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in dp for any larger i, j. dp[i][j] be the length of the longest common subarray starting at A[i] and B[j].       





----------------------------------

## Code Exhibition
Talk is cheap, show me the code.    
### Code in Java.       
I. Dynamic Programming       
Time Complexity: O(M* N), where M, N are the lengths of A, B.      
Space Complexity: O(M* N), the space used by dp.     

    public int findLength(int[] A, int[] B) {
        //prepare for result
        int res = 0;
        
        //check for extreme condition
        if(A == null || B == null || B.length == 0){
            return res;
        }
        
        //Dynamic Programming   
        //dp[i][j] be the length of the longest common subarray starting at A[i] and B[j]
        int[][] dp = new int[A.length + 1][B.length +1];
        
        for(int i = A.length - 1; i >= 0; --i){
            for(int j = B.length - 1; j >= 0; --j){
                if(A[i] == B[j]){
                    dp[i][j] = dp[i+1][j+1] + 1; //previous value + 1 for the length
                    if(res < dp[i][j]){
                        res = dp[i][j];
                    }
                }
            }
        }
        
        return res;
        
    }


III. Brute force but TLE.     
Time Complexity: O(M∗N∗min(M,N)), where M, N are the lengths of A, B. The worst case is when all the elements are equal.       

    public int findLength(int[] A, int[] B) {
        //prepare for result
        int res = 0;
        
        //check for extreme condition
        if(A == null || B == null || B.length == 0){
            return res;
        }
        
        //check for every subarray
        for(int i = 0; i < A.length; i++){
            for(int j = 0; j < B.length; j++){
                int k = 0;
                
                while(i + k < A.length && j + k < B.length && A[i+k] == B[j+k]){
                    k++;
                }
                
                res = Math.max(res, k);
            }
        }
        
        return res;
    }




### Code in Python.   
Dynamic Programming     

    class Solution(object):
        def findLength(self, A, B):
          memo = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]
          for i in range(len(A) - 1, -1, -1):
             for j in range(len(B) - 1, -1, -1):
                 if A[i] == B[j]:
                     memo[i][j] = memo[i+1][j+1]+1
          return max(max(row) for row in memo)



