---
title: 108. Convert Sorted Array to Binary Search Tree (Easy)                   
author: zhou      
tags: [Tree, Depth-first Search]            
---

       

## Catalog  
+ [Question Description](#partI)
+ [My Thoughts](#partII)
+ [Code Exhibition](#partIII)

----------------------------------

## Question Description
Clear language for describing question.    

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.     
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.     

Example:    
Given the sorted array: [-10,-3,0,5,9],     
One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:     

      0    
     / \   
   -3   9   
   /   /   
 -10  5      
 

----------------------------------

## My Thoughts
My thoughts for solving question after thinking and checking others' solving methods.        

height balanced BST: Height is balanced is enough! So pick middle node as root, low as left, high as right.     

I. Recursion     
Your input     
[-10,-3,0,5,9]   
Output   
[0,-10,5,null,-3,null,9]   
Expected   
[0,-3,9,-10,null,5]   

II. Iterative     
I came up with the recursion solution first and tried to translate it into an iterative solution. It is very similar to doing a tree inorder traversal, I use three stacks - nodeStack stores the node I am going to process next, and leftIndexStack and rightIndexStack store the range where this node need to read from the nums.      



----------------------------------

## Code Exhibition
Talk is cheap, show me the code.    
### Code in Java.     
Recursion    

    class Solution {
      public TreeNode sortedArrayToBST(int[] num) {
        if (num.length == 0) {
            return null;
        }
        
        TreeNode head = helper(num, 0, num.length - 1);
        return head;
      }

      public TreeNode helper(int[] num, int low, int high) {
        if (low > high) { // Done
            return null;
        }
        
        //int mid = (low + high) / 2;
        int mid = low + (high-low)/2; // avoids integer overflow
        TreeNode node = new TreeNode(num[mid]);
        node.left = helper(num, low, mid - 1);
        node.right = helper(num, mid + 1, high);
        
        return node;
      }
    }

Iterative    

    public TreeNode sortedArrayToBST(int[] nums) {
        //Iterative 
        
        if(nums == null || nums.length == 0){
            return null;
        }
        
        TreeNode root = new TreeNode(0);
        
        Stack<Object> stack = new Stack<>();
        stack.push(nums.length-1);
        stack.push(0);
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode node = (TreeNode)stack.pop();
            int begin = (int)stack.pop();
            int end = (int)stack.pop();
            int mid = begin + ((end - begin) >> 1);
            node.val = nums[mid];
            if (end >= mid+1) {
                node.right = new TreeNode(0);
                stack.push(end);
                stack.push(mid+1);
                stack.push(node.right);
            }
            if (begin <= mid-1) {
                node.left = new TreeNode(0);
                stack.push(mid-1);
                stack.push(begin);
                stack.push(node.left);
            }
        }
        return root;
    }


### Code in Python.   




