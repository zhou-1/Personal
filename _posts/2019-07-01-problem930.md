---
title: 930. Binary Subarrays With Sum (medium)                  
author: zhou      
tags: [HashTable,Two Pointers]          
---

       

## Catalog  
+ [Question Description](#partI)
+ [My Thoughts](#partII)
+ [Code Exhibition](#partIII)

----------------------------------

## Question Description
Clear language for describing question.    
In an array A of 0s and 1s, how many non-empty subarrays have sum S?      

Example 1:     
Input: A = [1,0,1,0,1], S = 2    
Output: 4   
Explanation:     
The 4 subarrays are bolded below:    
[1,0,1]      
[1,0,1,0]      
[0,1,0,1]       
[1,0,1]     

Note:     
A.length <= 30000    
0 <= S <= A.length    
A[i] is either 0 or 1.     


----------------------------------

## My Thoughts
My thoughts for solving question after thinking and checking others' solving methods.        
First, brute force. Check for every subarray within two for loops. 
Second, Prefix sums and HashMap. Check for map has x of int[] P or not, and every time put (x + S) in map.    






----------------------------------

## Code Exhibition
Talk is cheap, show me the code.    
### Code in Java.     
Brute force.    
Time Complexity: O(N^2)    

    public int numSubarraysWithSum(int[] A, int S) {
        //prepare for result
        int res = 0;
        
        //check for extreme condition
        if(A == null || A.length == 0){
            return res;
        }
        
        //check for every element
        for(int i = 0; i < A.length; i++){
            int complement = S - A[i];
            if(complement == 0){
                res++;
            }
            for(int j = i + 1; j < A.length; j++){
                complement -= A[j];
                if(complement == 0){
                    res++;
                }
            }
        }
        return res;
        
    }

Prefix sums and HashMap<x + S, frequence>      
Time Complexity: O(N)O(N), where NN is the length of A.      

Space Complexity: O(N)O(N).      

    public int numSubarraysWithSum(int[] A, int S) {
        //prepare for result
        int res = 0;
        
        //check for extreme condition
        if(A == null || A.length == 0){
            return res;
        }
        
        int N = A.length;
        int[] P = new int[N + 1];
        for(int i = 0; i < N; ++i){
            P[i + 1] = P[i] + A[i];
        }
        
        HashMap<Integer, Integer> map = new HashMap<> ();
        for(int x : P){
            res += map.getOrDefault(x, 0);
            map.put(x + S, map.getOrDefault(x + S, 0) + 1);
        }
        
        return res;
        
    }




### Code in Python.   




