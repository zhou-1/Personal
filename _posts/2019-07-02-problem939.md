---
title: 939. Minimum Area Rectangle (medium)                  
author: zhou      
tags: [HashTable]          
---

       

## Catalog  
+ [Question Description](#partI)
+ [My Thoughts](#partII)
+ [Code Exhibition](#partIII)

----------------------------------

## Question Description
Clear language for describing question.    
Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.         
If there isn't any rectangle, return 0.      

Example 1:    
Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]     
Output: 4    

Example 2:    
Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]    
Output: 2     

Note:     
1 <= points.length <= 500    
0 <= points[i][0] <= 40000   
0 <= points[i][1] <= 40000   
All points are distinct.     



----------------------------------

## My Thoughts
My thoughts for solving question after thinking and checking others' solving methods.        
I. Sort by columns.     
Count each rectangle by right-most edge. Group the points by x coordinates, so that we have columns of points. Then, for every pair of points in a column (with coordinates (x,y1) and (x,y2)), check for the smallest rectangle with this pair of points as the rightmost edge. We can do this by keeping memory of what pairs of points we've seen before.        
Base on same column, we compare with previous x and current x.     






----------------------------------

## Code Exhibition
Talk is cheap, show me the code.    
### Code in Java.     
Sort by columns & TreeMap<Integer x, List for y> && HashMap<Integer for code, Integer for x>     

    public int minAreaRect(int[][] points) {
        //prepare for result    
        int res = 0;
        
        //check for extreme condition
        if(points == null || points.length < 4){
            return res;
        }
        
        //Sort by column
        
        //HashMap<column, list for rows>
        Map<Integer, List<Integer>> map = new TreeMap<> ();
        for(int[] point : points){
            int x = point[0], y = point[1];
            map.computeIfAbsent(x, z -> new ArrayList()).add(y); //based on x, add y
            
        }
        
        res = Integer.MAX_VALUE;
        Map<Integer, Integer> lastx = new HashMap<> ();
        for(int x : map.keySet()){ //for all x-plane
            //In same x, create a list for the y
            List<Integer> row = map.get(x);
            Collections.sort(row);
            for(int i = 0; i < row.size(); ++i){
                for(int j = i + 1; j < row.size(); ++j){
                    int y1 = row.get(i), y2 = row.get(j);//two y's
                    //0 <= points[i][0] <= 40000
                    //0 <= points[i][1] <= 40000
                    int code = 40001 * y1 + y2;
                    if(lastx.containsKey(code)){
                        res = Math.min(res, (x - lastx.get(code)) * (y2 - y1));
                    }
                    lastx.put(code, x);
                }
            }
        }
        
        return res < Integer.MAX_VALUE ? res : 0;
    }



### Code in Python.   




