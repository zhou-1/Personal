---
title: 141. Linked List Cycle (easy)                   
author: zhou      
tags: [Linked List, Two Pointers]            
---

       

## Catalog  
+ [Question Description](#partI)
+ [My Thoughts](#partII)
+ [Code Exhibition](#partIII)

----------------------------------

## Question Description
Clear language for describing question.    

Given a linked list, determine if it has a cycle in it.      
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.     

Example 1:     
Input: head = [3,2,0,-4], pos = 1    
Output: true    
Explanation: There is a cycle in the linked list, where tail connects to the second node.     
![Example Image1](img/img141-0.png )  

Example 2:     
Input: head = [1,2], pos = 0   
Output: true    
Explanation: There is a cycle in the linked list, where tail connects to the first node.     
![Example Image2](img/img141-1.png )  

Example 3:      
Input: head = [1], pos = -1   
Output: false    
Explanation: There is no cycle in the linked list.    
![Example Image3](img/img141-2.png )    


----------------------------------

## My Thoughts
My thoughts for solving question after thinking and checking others' solving methods.        

 It introduces the following ideas: Linked List, Hash Table and Two Pointers.     
 
Approach 1: Hash Table     
Intuition    
To detect if a list is cyclic, we can check whether a node had been visited before. A natural way is to use a hash table.    
Algorithm    
We go through each node one by one and record each node's reference (or memory address) in a hash table. If the current node is null, we have reached the end of the list and it must not be cyclic. If current nodeâ€™s reference is in the hash table, then return true.      






----------------------------------

## Code Exhibition
Talk is cheap, show me the code.    
### Code in Java.     
HashTable    

    public boolean hasCycle(ListNode head) {
      Set<ListNode> nodesSeen = new HashSet<>();
      while (head != null) {
         if (nodesSeen.contains(head)) {
             return true;
         } else {
             nodesSeen.add(head);
         }
         head = head.next;
      }
      return false;
    }



### Code in Python.   




